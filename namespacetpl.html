<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Template Piping Library: tpl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Template Piping Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tpl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the library. Stores all generators, operators and sinks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1cached__sequence.html">cached_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence caching any other sequence.  <a href="classtpl_1_1cached__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1cycle__sequence.html">cycle_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinite sequence generating repeating sequence of elements. E.g. given sequence <code>{ 1, 2 }</code> the output sequence would be <code>{ 1, 2, 1, 2, 1,... }</code>.  <a href="classtpl_1_1cycle__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1dropping__sequence.html">dropping_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence omitting given numer of elements from the begin. E.g. for sequence <code>{ 1, 2, 3, 4 }</code> and argument <code>toDrop</code> equal to 2 output sequence is <code>{ 3, 4 }</code>.  <a href="classtpl_1_1dropping__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1filtered__sequence.html">filtered_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence filtering given sequence using supplied function.  <a href="classtpl_1_1filtered__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1flattened__sequence.html">flattened_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence concatenating internal sequences of input sequence.  <a href="classtpl_1_1flattened__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1generated__sequence.html">generated_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinite sequence generating elements utilizing function. E.g. for given function <code>[](int i){ return i + 2; }</code> and initial value 3 the generated sequence is <code>{ 3, 5, 7, ... }</code>.  <a href="classtpl_1_1generated__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1grouped__sequence.html">grouped_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence grouping input sequence into associative container of sequences using given predicate.  <a href="classtpl_1_1grouped__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1infinite__sequence.html">infinite_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinite sequence repeating indefinitely one value. E.g. for given value 5 the output sequence is <code>{ 5, 5, 5,... }</code>.  <a href="classtpl_1_1infinite__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1keys__sequence.html">keys_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence extracting keys from input associative sequence.  <a href="classtpl_1_1keys__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1mapped__values__sequence.html">mapped_values_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence extracting mapped values from input associative sequence.  <a href="classtpl_1_1mapped__values__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1no__operation__sequence.html">no_operation_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence only wrapping given sequence.  <a href="classtpl_1_1no__operation__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1reversing__sequence.html">reversing_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence reversing order of elements in input sequence.  <a href="classtpl_1_1reversing__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1sorted__sequence.html">sorted_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence sorting elements in input sequence.  <a href="classtpl_1_1sorted__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1taken__sequence.html">taken_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence taking given number of elements from input sequence.  <a href="classtpl_1_1taken__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1transformed__sequence.html">transformed_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence transforming values from input sequence using given predicate.  <a href="classtpl_1_1transformed__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpl_1_1ziped__sequence.html">ziped_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence zipping together two sequences.  <a href="classtpl_1_1ziped__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3c2be3a7f5e6c670de1ab525d2f5081"><td class="memTemplParams" colspan="2">template&lt;class Enumerable &gt; </td></tr>
<tr class="memitem:ab3c2be3a7f5e6c670de1ab525d2f5081"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpl_1_1cycle__sequence.html">cycle_sequence</a>&lt; Enumerable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#ab3c2be3a7f5e6c670de1ab525d2f5081">cycle</a> (Enumerable &amp;&amp;enumerable)</td></tr>
<tr class="memdesc:ab3c2be3a7f5e6c670de1ab525d2f5081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping generator repeating infintely given sequence. E.g. given sequence <code>{ 1, 2 }</code> the output sequence would be <code>{ 1, 2, 1, 2, 1,... }</code>.  <a href="#ab3c2be3a7f5e6c670de1ab525d2f5081">More...</a><br /></td></tr>
<tr class="separator:ab3c2be3a7f5e6c670de1ab525d2f5081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75855af3536df63c6966665617ea482f"><td class="memTemplParams" colspan="2">template&lt;class GeneratingFunction , class ValueType &gt; </td></tr>
<tr class="memitem:a75855af3536df63c6966665617ea482f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpl_1_1generated__sequence.html">generated_sequence</a>&lt; GeneratingFunction, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a75855af3536df63c6966665617ea482f">generator</a> (GeneratingFunction &amp;&amp;generatingFunction, ValueType &amp;&amp;initialValue)</td></tr>
<tr class="memdesc:a75855af3536df63c6966665617ea482f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping generator based on a function. E.g. for given function <code>[](int i){ return i + 2; }</code> and initial value 3 the generated sequence is <code>{ 3, 5, 7, ... }</code>.  <a href="#a75855af3536df63c6966665617ea482f">More...</a><br /></td></tr>
<tr class="separator:a75855af3536df63c6966665617ea482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c0311242c7968a78efd4245c4253bc"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:ab7c0311242c7968a78efd4245c4253bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpl_1_1infinite__sequence.html">infinite_sequence</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#ab7c0311242c7968a78efd4245c4253bc">infinite</a> (ValueType &amp;&amp;value)</td></tr>
<tr class="memdesc:ab7c0311242c7968a78efd4245c4253bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping generator which repeats indefinitely one value. E.g. for given value 5 the output sequence is <code>{ 5, 5, 5,... }</code>.  <a href="#ab7c0311242c7968a78efd4245c4253bc">More...</a><br /></td></tr>
<tr class="separator:ab7c0311242c7968a78efd4245c4253bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948593d51d280058e4c636fd1fcabc96"><td class="memItemLeft" align="right" valign="top">drop_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a948593d51d280058e4c636fd1fcabc96">drop</a> (unsigned toDrop)</td></tr>
<tr class="memdesc:a948593d51d280058e4c636fd1fcabc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator used to omit given numer of elements from the begin. E.g. for input sequence <code>{ 1, 2, 3, 4 }</code> and argument <code>toDrop</code> equal to 2 output sequence is <code>{ 3, 4 }</code>.  <a href="#a948593d51d280058e4c636fd1fcabc96">More...</a><br /></td></tr>
<tr class="separator:a948593d51d280058e4c636fd1fcabc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb6c42201b84ffcfa3c8f4fcd3dbaec"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:abcb6c42201b84ffcfa3c8f4fcd3dbaec"><td class="memTemplItemLeft" align="right" valign="top">filter_factory&lt; Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#abcb6c42201b84ffcfa3c8f4fcd3dbaec">filter</a> (Predicate &amp;&amp;predicate)</td></tr>
<tr class="memdesc:abcb6c42201b84ffcfa3c8f4fcd3dbaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator filtering input sequence using supplied function.  <a href="#abcb6c42201b84ffcfa3c8f4fcd3dbaec">More...</a><br /></td></tr>
<tr class="separator:abcb6c42201b84ffcfa3c8f4fcd3dbaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437c8737bd3ccee8a8217061d26df771"><td class="memTemplParams" colspan="2">template&lt;class Grouping &gt; </td></tr>
<tr class="memitem:a437c8737bd3ccee8a8217061d26df771"><td class="memTemplItemLeft" align="right" valign="top">grouping_factory&lt; Grouping &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a437c8737bd3ccee8a8217061d26df771">group_by</a> (Grouping &amp;&amp;grouping)</td></tr>
<tr class="memdesc:a437c8737bd3ccee8a8217061d26df771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator grouping input sequence into map of sequences using given predicate.  <a href="#a437c8737bd3ccee8a8217061d26df771">More...</a><br /></td></tr>
<tr class="separator:a437c8737bd3ccee8a8217061d26df771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436aa8c9686ec2d43c50a24e7ac12729"><td class="memTemplParams" colspan="2">template&lt;class Comparison &gt; </td></tr>
<tr class="memitem:a436aa8c9686ec2d43c50a24e7ac12729"><td class="memTemplItemLeft" align="right" valign="top">compare_factory&lt; Comparison &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a436aa8c9686ec2d43c50a24e7ac12729">sort</a> (Comparison &amp;&amp;comparison)</td></tr>
<tr class="memdesc:a436aa8c9686ec2d43c50a24e7ac12729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator sorting elements in input sequence.  <a href="#a436aa8c9686ec2d43c50a24e7ac12729">More...</a><br /></td></tr>
<tr class="separator:a436aa8c9686ec2d43c50a24e7ac12729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617fbdb245356ecad14c311f4d698ba6"><td class="memItemLeft" align="right" valign="top">take_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a617fbdb245356ecad14c311f4d698ba6">take</a> (unsigned toTake)</td></tr>
<tr class="memdesc:a617fbdb245356ecad14c311f4d698ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator taking given number of elements from intput sequence and creating a new sequence from them.  <a href="#a617fbdb245356ecad14c311f4d698ba6">More...</a><br /></td></tr>
<tr class="separator:a617fbdb245356ecad14c311f4d698ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797b95172271b5b77ae5762c41c25d7b"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a797b95172271b5b77ae5762c41c25d7b"><td class="memTemplItemLeft" align="right" valign="top">transform_factory&lt; Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a797b95172271b5b77ae5762c41c25d7b">transform</a> (Predicate &amp;&amp;transformPredicate)</td></tr>
<tr class="memdesc:a797b95172271b5b77ae5762c41c25d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator transforming intput sequence.  <a href="#a797b95172271b5b77ae5762c41c25d7b">More...</a><br /></td></tr>
<tr class="separator:a797b95172271b5b77ae5762c41c25d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365c06423a797a2625aefe7336d334f7"><td class="memTemplParams" colspan="2">template&lt;class Enumerable &gt; </td></tr>
<tr class="memitem:a365c06423a797a2625aefe7336d334f7"><td class="memTemplItemLeft" align="right" valign="top">zipped_enumerable_factory&lt; Enumerable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a365c06423a797a2625aefe7336d334f7">zip</a> (Enumerable &amp;&amp;enumerable)</td></tr>
<tr class="memdesc:a365c06423a797a2625aefe7336d334f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator zipping together two sequences the input one and the one passed as a parameter.  <a href="#a365c06423a797a2625aefe7336d334f7">More...</a><br /></td></tr>
<tr class="separator:a365c06423a797a2625aefe7336d334f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3792fb863312ee38506253a84357f"><td class="memTemplParams" colspan="2">template&lt;class LogicalPredicate &gt; </td></tr>
<tr class="memitem:a1be3792fb863312ee38506253a84357f"><td class="memTemplItemLeft" align="right" valign="top">all_sink_factory&lt; LogicalPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a1be3792fb863312ee38506253a84357f">all</a> (LogicalPredicate &amp;&amp;logicalPredicate)</td></tr>
<tr class="memdesc:a1be3792fb863312ee38506253a84357f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink checking if all elements in input sequence are compliant with given predicate.  <a href="#a1be3792fb863312ee38506253a84357f">More...</a><br /></td></tr>
<tr class="separator:a1be3792fb863312ee38506253a84357f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3748d14e83728498f41f3e79438242"><td class="memTemplParams" colspan="2">template&lt;class LogicalPredicate &gt; </td></tr>
<tr class="memitem:a8a3748d14e83728498f41f3e79438242"><td class="memTemplItemLeft" align="right" valign="top">any_sink_factory&lt; LogicalPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a8a3748d14e83728498f41f3e79438242">any</a> (LogicalPredicate &amp;&amp;logicalPredicate)</td></tr>
<tr class="memdesc:a8a3748d14e83728498f41f3e79438242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink checking if any element in input sequence is compliant with given predicate.  <a href="#a8a3748d14e83728498f41f3e79438242">More...</a><br /></td></tr>
<tr class="separator:a8a3748d14e83728498f41f3e79438242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1177a29a1b049aa67e46b56d73818b15"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a1177a29a1b049aa67e46b56d73818b15"><td class="memTemplItemLeft" align="right" valign="top">copy_to_factory&lt; OutputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a1177a29a1b049aa67e46b56d73818b15">copy_to</a> (OutputIterator &amp;&amp;outputIterator)</td></tr>
<tr class="memdesc:a1177a29a1b049aa67e46b56d73818b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink copying elements from input sequence to given output iterator.  <a href="#a1177a29a1b049aa67e46b56d73818b15">More...</a><br /></td></tr>
<tr class="separator:a1177a29a1b049aa67e46b56d73818b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b610330ed23e85d15a350b766d942a0"><td class="memTemplParams" colspan="2">template&lt;class LogicalPredicate &gt; </td></tr>
<tr class="memitem:a9b610330ed23e85d15a350b766d942a0"><td class="memTemplItemLeft" align="right" valign="top">count_factory&lt; LogicalPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a9b610330ed23e85d15a350b766d942a0">count</a> (LogicalPredicate &amp;&amp;logicalPredicate)</td></tr>
<tr class="memdesc:a9b610330ed23e85d15a350b766d942a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink counting number of elements complying with given predicate.  <a href="#a9b610330ed23e85d15a350b766d942a0">More...</a><br /></td></tr>
<tr class="separator:a9b610330ed23e85d15a350b766d942a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebfa7f20a13baa2d99ae20ffba86d3f"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a9ebfa7f20a13baa2d99ae20ffba86d3f"><td class="memTemplItemLeft" align="right" valign="top">fold_left_factory&lt; Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a9ebfa7f20a13baa2d99ae20ffba86d3f">fold_left</a> (Predicate &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a9ebfa7f20a13baa2d99ae20ffba86d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink performing on input sequence left fold. Left fold is also called reduce or accumulate.  <a href="#a9ebfa7f20a13baa2d99ae20ffba86d3f">More...</a><br /></td></tr>
<tr class="separator:a9ebfa7f20a13baa2d99ae20ffba86d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4987cc1e7df3aa34b1da647849267201"><td class="memTemplParams" colspan="2">template&lt;class Predicate , class InitialValue &gt; </td></tr>
<tr class="memitem:a4987cc1e7df3aa34b1da647849267201"><td class="memTemplItemLeft" align="right" valign="top">initialized_fold_left_factory&lt; Predicate, InitialValue &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a4987cc1e7df3aa34b1da647849267201">fold_left</a> (Predicate &amp;&amp;predicate, InitialValue &amp;&amp;initialValue)</td></tr>
<tr class="memdesc:a4987cc1e7df3aa34b1da647849267201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink performing on input sequence left fold. Left fold is also called reduce or accumulate.  <a href="#a4987cc1e7df3aa34b1da647849267201">More...</a><br /></td></tr>
<tr class="separator:a4987cc1e7df3aa34b1da647849267201"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adfe8b5ab6e957aebd640c3dc2b654c74"><td class="memItemLeft" align="right" valign="top">const cache_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#adfe8b5ab6e957aebd640c3dc2b654c74">cache</a></td></tr>
<tr class="memdesc:adfe8b5ab6e957aebd640c3dc2b654c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator used to cache given sequence.  <a href="#adfe8b5ab6e957aebd640c3dc2b654c74">More...</a><br /></td></tr>
<tr class="separator:adfe8b5ab6e957aebd640c3dc2b654c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb2279be98717d79771e606c72dea19"><td class="memItemLeft" align="right" valign="top">const flatten_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a5fb2279be98717d79771e606c72dea19">flatten</a></td></tr>
<tr class="memdesc:a5fb2279be98717d79771e606c72dea19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator concatenating internal sequences of input sequence.  <a href="#a5fb2279be98717d79771e606c72dea19">More...</a><br /></td></tr>
<tr class="separator:a5fb2279be98717d79771e606c72dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f450ed21ec9b9fc7a0429ca0928f58"><td class="memItemLeft" align="right" valign="top">const keys_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#ac8f450ed21ec9b9fc7a0429ca0928f58">keys</a></td></tr>
<tr class="memdesc:ac8f450ed21ec9b9fc7a0429ca0928f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator extracting keys from input associative sequence.  <a href="#ac8f450ed21ec9b9fc7a0429ca0928f58">More...</a><br /></td></tr>
<tr class="separator:ac8f450ed21ec9b9fc7a0429ca0928f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264f44784544179e65018a6aebe2c3c"><td class="memItemLeft" align="right" valign="top">const mapped_values_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#ae264f44784544179e65018a6aebe2c3c">mapped_values</a></td></tr>
<tr class="memdesc:ae264f44784544179e65018a6aebe2c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator extracting mapped values from input associative sequence.  <a href="#ae264f44784544179e65018a6aebe2c3c">More...</a><br /></td></tr>
<tr class="separator:ae264f44784544179e65018a6aebe2c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514857da4c8cea7bd8bfbd60386b586"><td class="memItemLeft" align="right" valign="top">const no_operation_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#a8514857da4c8cea7bd8bfbd60386b586">no_operation</a></td></tr>
<tr class="memdesc:a8514857da4c8cea7bd8bfbd60386b586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator wrapping input sequence.  <a href="#a8514857da4c8cea7bd8bfbd60386b586">More...</a><br /></td></tr>
<tr class="separator:a8514857da4c8cea7bd8bfbd60386b586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d53f704bb46491e8db11a7a9928fdf"><td class="memItemLeft" align="right" valign="top">const reverse_factory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpl.html#ae0d53f704bb46491e8db11a7a9928fdf">reverse</a></td></tr>
<tr class="memdesc:ae0d53f704bb46491e8db11a7a9928fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piping operator for reversing order of elements in input sequence.  <a href="#ae0d53f704bb46491e8db11a7a9928fdf">More...</a><br /></td></tr>
<tr class="separator:ae0d53f704bb46491e8db11a7a9928fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace of the library. Stores all generators, operators and sinks. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab3c2be3a7f5e6c670de1ab525d2f5081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c2be3a7f5e6c670de1ab525d2f5081">&#9670;&nbsp;</a></span>cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpl_1_1cycle__sequence.html">cycle_sequence</a>&lt;Enumerable&gt; tpl::cycle </td>
          <td>(</td>
          <td class="paramtype">Enumerable &amp;&amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping generator repeating infintely given sequence. E.g. given sequence <code>{ 1, 2 }</code> the output sequence would be <code>{ 1, 2, 1, 2, 1,... }</code>. </p>
<p>Complexity:</p><ul>
<li>O(1) for rvalue references (std::move is prefered)</li>
<li>O(N) for lvalue references (N is size of enumerable)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>Type of sequence to be repeated. This type must satisfy is_enumerable trait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Sequence to be repeated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cycle_equence infinitely repeating given sequence. </dd></dl>

</div>
</div>
<a id="a75855af3536df63c6966665617ea482f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75855af3536df63c6966665617ea482f">&#9670;&nbsp;</a></span>generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GeneratingFunction , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpl_1_1generated__sequence.html">generated_sequence</a>&lt;GeneratingFunction, ValueType&gt; tpl::generator </td>
          <td>(</td>
          <td class="paramtype">GeneratingFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>generatingFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping generator based on a function. E.g. for given function <code>[](int i){ return i + 2; }</code> and initial value 3 the generated sequence is <code>{ 3, 5, 7, ... }</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneratingFunction</td><td>Type of function used to generate subsequent elements. It should take one argument of type convertible to ValueType and return type convertible to ValueType. If you are trying to use multiple iterators from this sequence the function cannot have side-effects or the behaviour is unspecified. </td></tr>
    <tr><td class="paramname">ValueType</td><td>Objects of this type will be returned from iterator. This type must be copy-constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generatingFunction</td><td>Function to be used to generate subsequent values. </td></tr>
    <tr><td class="paramname">initialValue</td><td>Value used to initialize the generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generator_sequence using given function and initialValue to generate subsequent values. </dd></dl>

</div>
</div>
<a id="ab7c0311242c7968a78efd4245c4253bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c0311242c7968a78efd4245c4253bc">&#9670;&nbsp;</a></span>infinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpl_1_1infinite__sequence.html">infinite_sequence</a>&lt;ValueType&gt; tpl::infinite </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping generator which repeats indefinitely one value. E.g. for given value 5 the output sequence is <code>{ 5, 5, 5,... }</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Objects of this type will be returned from iterator. This type must be copy-constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value that is returned by the iterators of this sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtpl_1_1infinite__sequence.html" title="Infinite sequence repeating indefinitely one value. E.g. for given value 5 the output sequence is { 5...">infinite_sequence</a> repeating all the time given value. </dd></dl>

</div>
</div>
<a id="a948593d51d280058e4c636fd1fcabc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948593d51d280058e4c636fd1fcabc96">&#9670;&nbsp;</a></span>drop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drop_factory tpl::drop </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>toDrop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator used to omit given numer of elements from the begin. E.g. for input sequence <code>{ 1, 2, 3, 4 }</code> and argument <code>toDrop</code> equal to 2 output sequence is <code>{ 3, 4 }</code>. </p>
<p>This operator can be safely used with infinite sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toDrop</td><td>Number of elements that is to be omitted from the beginning of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
const auto filtered = v | tpl::drop(3);
for (auto val : filtered)
    std::cout &lt;&lt; val &lt;&lt; ", "; //displays 4, 5, 
</pre> 
</div>
</div>
<a id="abcb6c42201b84ffcfa3c8f4fcd3dbaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb6c42201b84ffcfa3c8f4fcd3dbaec">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">filter_factory&lt;Predicate&gt; tpl::filter </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator filtering input sequence using supplied function. </p>
<p>This operator can be safely used with infinite sequences.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FilterPredicate</td><td>Function-like type which will be used for filtering. It should take one argument convertible to value_type of input sequence and return value of type convertible to bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function returning false when element is to be filtered out and false otherwise. Accepted type of this function should be constructible from value_type of input sequence. This function CANNOT have side-effects.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
const auto filtered = v | tpl::filter([](auto i){ return i &gt; 2; });
for (auto val : filtered)
    std::cout &lt;&lt; val &lt;&lt; ", "; //displays 3, 4, 5, 
</pre> 
</div>
</div>
<a id="a437c8737bd3ccee8a8217061d26df771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437c8737bd3ccee8a8217061d26df771">&#9670;&nbsp;</a></span>group_by()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Grouping &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">grouping_factory&lt;Grouping&gt; tpl::group_by </td>
          <td>(</td>
          <td class="paramtype">Grouping &amp;&amp;&#160;</td>
          <td class="paramname"><em>grouping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator grouping input sequence into map of sequences using given predicate. </p>
<p>This operator cannnot be safely used with infinite sequences - it eagerly processes the input sequence.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Grouping</td><td>Type of function used to group elements from enumerable. It must take one argument constructible from Enumerable::value_type and return any copy-constructible type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grouping</td><td>Function used to group elements in given input sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input = { 1, 2, 3, 4, 5 };
const auto grouped = input | group_by([](auto i){ i &lt; 3; });
for (const auto &amp;pair : grouped) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": {";
    for (auto value : pair.second) 
        std::cout &lt;&lt; value &lt;&lt; ",";
    std::cout &lt;&lt; "}" &lt;&lt; std::endl;
    // output will be 
    // true : { 1, 2, },
    // false : { 3, 4, 5, },
    // or the lines will be in reverse order
}
</pre> 
</div>
</div>
<a id="a436aa8c9686ec2d43c50a24e7ac12729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436aa8c9686ec2d43c50a24e7ac12729">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Comparison &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">compare_factory&lt;Comparison&gt; tpl::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comparison</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator sorting elements in input sequence. </p>
<p>This class <b>cannot</b> be used with infinite sequences.</p>
<p>This class complies with is_enumerable trait, which allows it to be used in a pipeline.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Comparison</td><td>Type of function supplied to compare elements in input sequence. It must accept two arguments, each constructible from value_type of input sequence and return bool. It must follow strict weak ordering.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison</td><td>Function-like object used to compare elements of enumerable during sorting.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input = { 1, 3, 5, 2, 4 };
const auto out = input | tpl::sort([](auto i, auto j){ return i &lt; j; });
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 1, 2, 3, 4, 5,
</pre> 
</div>
</div>
<a id="a617fbdb245356ecad14c311f4d698ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617fbdb245356ecad14c311f4d698ba6">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">take_factory tpl::take </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>toTake</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator taking given number of elements from intput sequence and creating a new sequence from them. </p>
<p>This operator can be safely used with infinite sequences. Actually, it is designed to make finite sequences from infinite ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toTake</td><td>Numer of elements that are to be taken from the beginning of the input sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input = { 1, 3, 5, 2, 4 };
const auto out = input | tpl::take(3);
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 1, 3, 5,
</pre> 
</div>
</div>
<a id="a797b95172271b5b77ae5762c41c25d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797b95172271b5b77ae5762c41c25d7b">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">transform_factory&lt;Predicate&gt; tpl::transform </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>transformPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator transforming intput sequence. </p>
<p>This operator can be safely used with infinite sequences.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of function-like object used to transform elements in input sequence. It must take one argument constructible from value_type of input sequence and return type which is at least move constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformPredicate</td><td>Function-like object used for transforming elemnts in input sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input = { 1, 3, 5, 2, 4 };
const auto out = input | tpl::transform([](auto i){ return std::to_string(2 * i); });
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 2, 6, 10, 4, 8
</pre> 
</div>
</div>
<a id="a365c06423a797a2625aefe7336d334f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365c06423a797a2625aefe7336d334f7">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">zipped_enumerable_factory&lt;Enumerable&gt; tpl::zip </td>
          <td>(</td>
          <td class="paramtype">Enumerable &amp;&amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator zipping together two sequences the input one and the one passed as a parameter. </p>
<p>This operator can be safely used with infinite sequences.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>Type of sequence with which input sequence is to be zipped with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Sequence with which input enumerable is to be zipped with.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input1 = { 1, 3, 5, 2, 4 };
std::vector&lt;int&gt; input2 = { 4, 8, 0, 1, 5 };
const auto out = input1 | tpl::zip(input2);
for (auto value : out) 
    std::cout &lt;&lt; value.first &lt;&lt; ", " &lt;&lt; value.second &lt;&lt; ", ";
    //output will be 1, 4, 3, 8, 5, 0, 2, 1, 4, 5, 
</pre> 
</div>
</div>
<a id="a1be3792fb863312ee38506253a84357f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be3792fb863312ee38506253a84357f">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LogicalPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">all_sink_factory&lt;LogicalPredicate&gt; tpl::all </td>
          <td>(</td>
          <td class="paramtype">LogicalPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>logicalPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink checking if all elements in input sequence are compliant with given predicate. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LogicalPredicate</td><td>Type of function-like object which will be called on subsequent elements to check compliance with it. It must take one argument constructible from input sequence value_type and return value convertible to bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalPredicate</td><td>Function which will be tested on subsequent elements.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; const bool out1 = v | <a class="el" href="namespacetpl.html#a1be3792fb863312ee38506253a84357f" title="Sink checking if all elements in input sequence are compliant with given predicate.">tpl::all</a>([](auto i){ return i &gt; 2; }); const bool out2 = v | <a class="el" href="namespacetpl.html#a1be3792fb863312ee38506253a84357f" title="Sink checking if all elements in input sequence are compliant with given predicate.">tpl::all</a>([](auto i){ return i &lt; 20; }); // out1 == false and out2 == true </p>

</div>
</div>
<a id="a8a3748d14e83728498f41f3e79438242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3748d14e83728498f41f3e79438242">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LogicalPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">any_sink_factory&lt;LogicalPredicate&gt; tpl::any </td>
          <td>(</td>
          <td class="paramtype">LogicalPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>logicalPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink checking if any element in input sequence is compliant with given predicate. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LogicalPredicate</td><td>Type of function-like object which will be called on subsequent elements to check compliance with it. It must take one argument constructible from input sequence value_type and return value convertible to bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalPredicate</td><td>Function which will be tested on subsequent elements.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; const bool out1 = v | <a class="el" href="namespacetpl.html#a8a3748d14e83728498f41f3e79438242" title="Sink checking if any element in input sequence is compliant with given predicate.">tpl::any</a>([](auto i){ return i &lt; 0; }); const bool out2 = v | <a class="el" href="namespacetpl.html#a8a3748d14e83728498f41f3e79438242" title="Sink checking if any element in input sequence is compliant with given predicate.">tpl::any</a>([](auto i){ return i &lt; 2; }); // out1 == false and out2 == true </p>

</div>
</div>
<a id="a1177a29a1b049aa67e46b56d73818b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1177a29a1b049aa67e46b56d73818b15">&#9670;&nbsp;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_to_factory&lt;OutputIterator&gt; tpl::copy_to </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>outputIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink copying elements from input sequence to given output iterator. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>Type of output iterator. Its value_type must be constructible from input sequence value_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputIterator</td><td>Iterator to which is copied input sequence.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; v | <a class="el" href="namespacetpl.html#a1177a29a1b049aa67e46b56d73818b15" title="Sink copying elements from input sequence to given output iterator.">tpl::copy_to</a>(std::ostream_iterator&lt;int&gt;(std::cout, ", ")); //prints 1, 2, 3, 4, 5, </p>

</div>
</div>
<a id="a9b610330ed23e85d15a350b766d942a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b610330ed23e85d15a350b766d942a0">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LogicalPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">count_factory&lt;LogicalPredicate&gt; tpl::count </td>
          <td>(</td>
          <td class="paramtype">LogicalPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>logicalPredicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink counting number of elements complying with given predicate. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LogicalPredicate</td><td>Type of output iterator. Its value_type must be constructible from input sequence value_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalPredicate</td><td>Predicate telling returning true when given element is to be counted by sink and false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; const unsigned out = v | <a class="el" href="namespacetpl.html#a9b610330ed23e85d15a350b766d942a0" title="Sink counting number of elements complying with given predicate.">tpl::count</a>([](auto i){ return i &gt; 3;}); // out is 2 </p>

</div>
</div>
<a id="a9ebfa7f20a13baa2d99ae20ffba86d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebfa7f20a13baa2d99ae20ffba86d3f">&#9670;&nbsp;</a></span>fold_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fold_left_factory&lt;Predicate&gt; tpl::fold_left </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink performing on input sequence left fold. Left fold is also called reduce or accumulate. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<p>In this version of sink default value of input sequence value_type is taken as initial fold value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of function-like object which will be used for fold. It must take two parameters constructible from input sequence value_type and return value convertible to its first argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function which will be used for fold.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; const int out = v | <a class="el" href="namespacetpl.html#a9ebfa7f20a13baa2d99ae20ffba86d3f" title="Sink performing on input sequence left fold. Left fold is also called reduce or accumulate.">tpl::fold_left</a>([](auto j, auto i){ return i + j; }); // out == 15 </p>

</div>
</div>
<a id="a4987cc1e7df3aa34b1da647849267201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4987cc1e7df3aa34b1da647849267201">&#9670;&nbsp;</a></span>fold_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate , class InitialValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initialized_fold_left_factory&lt;Predicate, InitialValue&gt; tpl::fold_left </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitialValue &amp;&amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink performing on input sequence left fold. Left fold is also called reduce or accumulate. </p>
<p>This is a sink, which means it can be used as final part of a pipeline.</p>
<p>In this version of sink passed argument is taken as initial fold value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of function-like object which will be used for fold. It must take two parameters constructible from input sequence value_type and return value convertible to its first argument. </td></tr>
    <tr><td class="paramname">InitialValue</td><td>Type of initial value of the fold. Must be convertible to type of first argument of the Predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function which will be used for fold. </td></tr>
    <tr><td class="paramname">initialValue</td><td>Initial value of the fold operation.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b></p>
<p>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; const int out = v | <a class="el" href="namespacetpl.html#a9ebfa7f20a13baa2d99ae20ffba86d3f" title="Sink performing on input sequence left fold. Left fold is also called reduce or accumulate.">tpl::fold_left</a>([](auto j, auto i){ return i + j; }, 5); // out == 20 </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="adfe8b5ab6e957aebd640c3dc2b654c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe8b5ab6e957aebd640c3dc2b654c74">&#9670;&nbsp;</a></span>cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cache_factory tpl::cache</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator used to cache given sequence. </p>
<p>This operator is useful when using other operator which does any kind of heavy or costly processing. It eagerly processes the iterators of given sequence and stores the results so that they are available immidiately. This operator CANNOT be used with infinite sequences.</p>
<p><b>Complexity</b></p>
<ul>
<li>O(1) for rvalue references</li>
<li>O(N) for lvalue references (N is size of enumerable) </li>
</ul>

</div>
</div>
<a id="a5fb2279be98717d79771e606c72dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb2279be98717d79771e606c72dea19">&#9670;&nbsp;</a></span>flatten</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const flatten_factory tpl::flatten</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator concatenating internal sequences of input sequence. </p>
<p>This operator can be safely used with infinite sequences.</p>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;std::vector&lt;int&gt;&gt; v = { { 1, 2 }, {}, { 3 }, { 4, 5, 6, 7 }};
const auto flattened  = v | tpl::flatten;
for (auto val : flattened)
    std::cout &lt;&lt; val &lt;&lt; ", "; //displays 1, 2, 3, 4, 5, 6, 7,
</pre> 
</div>
</div>
<a id="ac8f450ed21ec9b9fc7a0429ca0928f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f450ed21ec9b9fc7a0429ca0928f58">&#9670;&nbsp;</a></span>keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const keys_factory tpl::keys</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator extracting keys from input associative sequence. </p>
<p>This operator can be safely used with infinite sequences.</p>
<p><b>Example</b> </p><pre class="fragment">std::map&lt;int, int&gt; input = { 
    { 1, 10 }, 
    { 2, 20 }, 
    { 3, 30 },
    { 4, 40 },
    { 5, 50 }
};
const auto out = input | tpl::keys;
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 1, 2, 3, 4, 5
</pre> 
</div>
</div>
<a id="ae264f44784544179e65018a6aebe2c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264f44784544179e65018a6aebe2c3c">&#9670;&nbsp;</a></span>mapped_values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const mapped_values_factory tpl::mapped_values</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator extracting mapped values from input associative sequence. </p>
<p>This operator can be safely used with infinite sequences.</p>
<p><b>Example</b> </p><pre class="fragment">std::map&lt;int, int&gt; input = { 
    { 1, 10 }, 
    { 2, 20 }, 
    { 3, 30 },
    { 4, 40 },
    { 5, 50 }
};
const auto vals = input | tpl::mapped_values;
for (auto value : vals) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 10, 20, 30, 40, 50
</pre> 
</div>
</div>
<a id="a8514857da4c8cea7bd8bfbd60386b586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8514857da4c8cea7bd8bfbd60386b586">&#9670;&nbsp;</a></span>no_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const no_operation_factory tpl::no_operation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator wrapping input sequence. </p>
<p>This operator can be safely used with infinite sequences.</p>
<p><b>Example</b> </p><pre class="fragment">std::map&lt;int, int&gt; input = { 1, 2, 3, 4, 5 };
const auto out = input | tpl::no_operation;
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 1, 2, 3, 4, 5
</pre> 
</div>
</div>
<a id="ae0d53f704bb46491e8db11a7a9928fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d53f704bb46491e8db11a7a9928fdf">&#9670;&nbsp;</a></span>reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reverse_factory tpl::reverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Piping operator for reversing order of elements in input sequence. </p>
<p>This operator <b>cannot</b> be used with infinite sequences.</p>
<p><b>Example</b> </p><pre class="fragment">std::vector&lt;int&gt; input = { 1, 2, 3, 4, 5 };
const auto out = input | tpl::reverse;
for (auto value : out) 
    std::cout &lt;&lt; value &lt;&lt; ", ";//output will be 5, 4, 3, 2, 1,
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
